---
layout: page
title: "ACA"
description: "Theory for Advanced Computer Architecture"
---

Computer Organization - Computer organization refers to how the operational attributes are linked together and contribute to realize the architectural specifications.
Like physical address memory, CPU are common architectural attributes and how they should be made & made to coordinate with each other.     

Computer Architecture - Combination of software & hardware. The instructions are implemented on hardware using some language to perform some task.

Advanced Computer Architecture - Reflects the advancement in the languages & hardware used along with the advancement in different parts of computer.    

#Terminologies

*STATE* - A particular configuration of storage i.e registers & memory.    
*STATE TRANSITION* - A change in the state of the machine.     
*CYCLE* - Time between the start of one state and the start of next transition.. Time between state transitions.       
	Internal Cycle - If the register is being reconfigured, then that cycle is called internal/machine cycle.     
	Memory Cycle - If the memory is being reconfigured, then that cycle is called memory cycle.     
*COMMAND* - A function that changes the state. Eg, instructions.    
*PROCESS* - Sequence of commands. Initial state -> Final State.     
*MACHINE* - Commands+storage+Implementation methods which cause state transitions.       
*PROCESSOR* - A processor constitutes of 3 main units : 
		Control Unit - Decoding circuitry decodes and interprets the instruction from the IR.
		Data Paths - Responsible for all the data processing. Eg, ALU.    
		Memory Unit - Includes MAR, storage register & memory itself.   


**INSTRUCTION** - An instruction is a vector of bits that specify : 
			-The format of instruction.
			-Operands
			-Opcode

	{% highlight c %}
	R1<-R2 //Copy contents of R2 to R1
	SR<-Mem[MAR] //Memory Read Operation : Contents of address in MAR are fetched into storage register.
	Mem[MAR]<-SR //Memory Write Operation: Contents of Storage Register are copied into MAR.
	PC<-*+1 //Current value in PC is incremented by 1.
	{% endhighlight %}

Major functional Parts in Computer : 
	- CPU
	- Memory
	- I/O

Major Parts of CPU: 
	- CU : Initiales sequences of micro-operations. 2 Ways of implementing, Hardwired & Micro-Programmed.
	- ALU
	- Memory Unit

In a microprogrammed computer, there are 2 seperate memories: 
	- Main Memory : Used to store programs. Read & Write both.
	- Control Memory : Holds a microprogram that can't be altered occasionally. No write operation permitted. Eg, ROM.

Componenets of Memory Organization for Microprogramed Computers: 
	- Control Word: Specifies one or more micro-operations.
	- Next Address Generator: While microoperations are executed, the next address is generated by this.  
	- Control Address Register: Reads next microinstruction from control memory.
	- Control Memory: Like ROM. Read only access. No write permissions for users.
	- Control Data Register: Holds present microinstruction while next address is computer & read from memory.

**Hardwired** 
1. It is fast because the control signals are circuit based. Uses flipflops and logic gates, etc.
2. If we need more control signals then the design gets more complex.
3. This is rigid because the modifications cannot be made easily. We need to reimplement the hardware by rearranging wires and logic gates.
4. Difficult to correct mistakes or add new features as it requires to rearrange the hardware accordingly.
5. The faults are usually diagnosed by gates, flip-flops etc. No software implementation is required.

**Micro-Programmed**
1. Based upon sequence of micro-operations which are used to initiate programs.
2. Even if we need more control signals, the design still remains less complex as compared to hardwired becuase in micro-programmed we use software routines.
3. This is more flexible because modifications can be easily implemented using software routines.
4. Correcting mistakes is easier as it requires us to just change the control sotware information.
5. The fault can be easily fixed by diagnostic tools & by checking values in flags, registers and counters.

DATA Types: Format of data objects. The various possible values that a data object can take.

Instruction format: Opcode + Address Field + Mode Field
	- Opcode : Specifies operation to be performed.
	- Address Field : Designates a memory address. 
	- Mode Field : Specifies the way operand or effective address is determined.

*Types for formats*: 
	- Three Address : Needs 3 address fields. The register address field may be processor register or memory. Eg, <code>ADD R1,R2,R3</code> denotes R1=R2+R3.
	- Two Address : Needs 2 address fields. Either register or memory.
	- One Address : Accumulator is used for all data manipulations.
	- Zero Address : Stack organized computer. No address field.

*Addressing Modes*: Method of choosing operands during program execution. It specifies a rule for interpreting/modifying address field of the instruction before operand is referenced.
1. Immediate Addressing : Operand is present in instruction itself. Simple instruction fetch is required to obtain operand. 
2. Direct Addressing : The address field contains the effective address of operand.
3. Indirect Addressing : The address field contains an address which gives the value of the pointer to the operand.
4. Register Addressing : Similar to direct addressing. The address field gives the effective address of operand lying in the register instead of main memory.


##FLYNN'S CLASSIFICATION (1966)

- Based on the notion of a stream of information.

Two types of information flow into a processor:   
1. Instruction Stream: Algorithms. A series of steps designed to solve a problem.
2. Data Stream: Information from memory used a input values too algorithms.

There are basically 4 types: 
1. SISD : Single Instruction Single Data - Single processor executes a single instruction stream to operate on data stored in single memory.
2. SIMD : Single Instruction Multiple Data - Multiple processors, same operation on multiple data points simultaneously. Data level Parallelism.
3. MISD : Multiple Instruction Single Data - Multiple processors, different operations, same data.
4. MIMD : Multiple Instruction Multiple Data - Multiple independent processors, executing different operations, different instructions, different data. Eg, multicore CPU.

#System Attributes: 
1. Clock Rate & CPI
	- Clock Cycle Time : CPU driven by a clock with a constant CCT.
	- Clock cycle is the time between two adjacent pulses of the oscillator that sets the tempo of the processor. <code>No. of pulses/second = clock speed (Ghz)</code>
	- Inverse of cycle time = clock rate.
	- Size of program : Determined by INSTRUCTION COUNT (no. of machine instructions to be executed in the program).
	- CPI: Cycles Per Instruction becomes an important parameter for measuring time needed to execute each instruction.

2. MIPS RATE 
	- Speed of the processor is in terms of Million Instruction/second (MIPS).

3. THROUGHPUT RATE 
	- <code>No. of programs a system can execute/Time taken = System throughput (Ws in programs/second)</code>

4. PROGRAMMING ENVIRONMENTS
	- The programming environment should be user friendly.

#Write Through 
On a write request by the CPU, check if the old data is in the cache.
If the old data is in the cache (Write Hit), write the new data into the cache, and also into memory, replacing the old data in both cache and memory.
If the old data is not in the cache (Write Miss), either:
Load the line to cache, and write the new data to both cache and memory (this method is called write-allocate), or
Just write the new data to memory, don’t load the line to cache (this method is called no-write-allocate)
Advantage: Keeps cache and memory consistent
Disadvantage: Needs to stall for memory access on every memory write
To reduce this problem, use a write buffer. When the CPU wants to write a word to memory, it puts the word into the write buffer, and then continues executing the instructions following the memory write. Simultaneously, the write buffer writes the words to memory.

#Write Back 

When the instruction requires a write to memory,
If there is a cache hit, write only to the cache.
Later, if there is a cache miss, and this line needs to be replaced, write the data back to memory.
If there is a cache miss, either
Load the line to cache, and write the new data to both cache and memory (this method is called write-allocate), or
Just write the new data to memory, don’t load the line to cache (this method is called no-write-allocate)
In the Write-back method, we have a dirty bit associated with each cache entry. If the dirty bit is set to 1, we need to write back to memory when this cache entry needs to be replaced. If the dirty bit is 0, we don’t need to write back to memory, saving CPU stalls
Disadvantage of Write-Back approach: Inconsistency - memory contains stale data
Note: Write-allocate is usually used with write-back. No-write-allocate is usually used with write-through.




{% include JB/setup %}
